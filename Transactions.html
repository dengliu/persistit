<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Transactions &mdash; Persistit 3.3.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.3.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Persistit 3.3.1 documentation" href="index.html" />
    <link rel="next" title="Physical B+Tree Representation" href="PhysicalStorage.html" />
    <link rel="prev" title="Basic API" href="BasicAPI.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="PhysicalStorage.html" title="Physical B+Tree Representation"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="BasicAPI.html" title="Basic API"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Persistit 3.3.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="transactions">
<span id="id1"></span><h1>Transactions<a class="headerlink" href="#transactions" title="Permalink to this headline">¶</a></h1>
<p>Akiban Persistit supports transactions with multi-version concurrency control (MVCC) using a protocol called Snapshot Isolation (SI). An application calls <a class="reference external" href="apidocs/com/persistit/Transaction.html#begin()">begin</a>, <a class="reference external" href="apidocs/com/persistit/Transaction.html#commit()">commit</a>, <a class="reference external" href="apidocs/com/persistit/Transaction.html#rollback()">rollback</a> and <a class="reference external" href="apidocs/com/persistit/Transaction.html#end()">end</a> methods to control the current transaction scope explicitly.  A Transaction allows an application to execute multiple database operations in an atomic, consistent, isolated and durable (ACID) manner.</p>
<p>Applications manage transactions through an instance of a <a class="reference external" href="apidocs/com/persistit/Transaction.html">com.persistit.Transaction</a> object. <tt class="docutils literal"><span class="pre">Transaction</span></tt> does not represent a single transaction, but is instead a context in which a thread may perform many sequential transactions. The general pattern is that the application gets the current thread’s <tt class="docutils literal"><span class="pre">Transaction</span></tt> instance, calls its <tt class="docutils literal"><span class="pre">begin</span></tt> method, performs work, calls <tt class="docutils literal"><span class="pre">commit</span></tt> and finally <tt class="docutils literal"><span class="pre">end</span></tt>.  The thread uses the same <tt class="docutils literal"><span class="pre">Transaction</span></tt> instance repeatedly. Generally each thread has one <tt class="docutils literal"><span class="pre">Transaction</span></tt> that lasts for the entire life of the thread (but see <a class="reference external" href="apidocs/com/persistit/Transaction.html">com.persistit.Transaction</a> for a mechanism that allows a transaction to be serviced by multiple threads).</p>
<div class="section" id="using-transactions">
<h2>Using Transactions<a class="headerlink" href="#using-transactions" title="Permalink to this headline">¶</a></h2>
<p>The following code fragment performs two store operations within the scope of a transaction:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="c1">//</span>
<span class="c1">// Get the transaction context for the current thread.</span>
<span class="c1">//</span>
<span class="n">Transaction</span> <span class="n">txn</span> <span class="o">=</span> <span class="n">myExchange</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
<span class="kt">int</span> <span class="n">remainingRetries</span> <span class="o">=</span> <span class="n">RETRY_COUNT</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
    <span class="n">txn</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">myExchange</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;First value&quot;</span><span class="o">);</span>
        <span class="n">myExchange</span><span class="o">.</span><span class="na">clear</span><span class="o">().</span><span class="na">append</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">store</span><span class="o">();</span>
        <span class="n">myExchange</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;Second value&quot;</span><span class="o">);</span>
        <span class="n">myExchange</span><span class="o">.</span><span class="na">clear</span><span class="o">().</span><span class="na">append</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">store</span><span class="o">();</span>
        <span class="c1">// Required to commit the transaction</span>
        <span class="n">txn</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RollbackException</span> <span class="n">re</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// perform any special rollback handling</span>
        <span class="c1">// allow loop to repeat until commit succeeds or retries</span>
        <span class="c1">// too many times.</span>
        <span class="k">if</span> <span class="o">(--</span><span class="n">remainingRetries</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nf">TransactionFailedException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">PersistitException</span> <span class="n">pe</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// handle other Persistit exception</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="c1">// Required to end the scope of a transaction.</span>
        <span class="n">txn</span><span class="o">.</span><span class="na">end</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This example catches <a class="reference external" href="apidocs/com/persistit/exception/RollbackException.html">com.persistit.exception.RollbackException</a> which can be thrown by any Persistit operation within the scope of a transaction, including <tt class="docutils literal"><span class="pre">commit</span></tt>. Any code explicitly running within the scope of a transaction should be designed to handle rollbacks.</p>
<p>This example also uses a <em>try/finally</em> block to ensure every call to <tt class="docutils literal"><span class="pre">begin</span></tt> has a matching call to <tt class="docutils literal"><span class="pre">end</span></tt>. This code pattern is mandatory: it is critical to correct transaction nesting behavior.</p>
<p>One convenient way to do this is to encapsulate the logic of a transaction in an implementation of <tt class="docutils literal"><span class="pre">com.persisitit.TransactionRunnable</span></tt> interface. The <a class="reference external" href="apidocs/com/persistit/Transaction.html#run(com.persistit.TransactionRunnable)">run</a> method automatically provides logic to begin the transaction, execute the TransactionRunnable and commit the transaction, repeating the process until no rollback is thrown or a maximum retry count is reached. For example, the code fragment shown above can be rewritten as:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="c1">//</span>
<span class="c1">// Get the transaction context for the current thread.</span>
<span class="c1">//</span>
<span class="n">Transaction</span> <span class="n">txn</span> <span class="o">=</span> <span class="n">myExchange</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
<span class="c1">//</span>
<span class="c1">// Perform the transaction with the following parameters:</span>
<span class="c1">// - try to commit it up to 10 times</span>
<span class="c1">// - delay 2 milliseconds before each retry</span>
<span class="c1">// - use the group commit durability policy</span>
<span class="c1">//</span>
<span class="n">txn</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="k">new</span> <span class="n">TransactionRunnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">PersistitException</span> <span class="o">{</span>
        <span class="n">myExchange</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;First value&quot;</span><span class="o">);</span>
        <span class="n">myExchange</span><span class="o">.</span><span class="na">clear</span><span class="o">().</span><span class="na">append</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">store</span><span class="o">();</span>
        <span class="n">myExchange</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;Second value&quot;</span><span class="o">);</span>
        <span class="n">myExchange</span><span class="o">.</span><span class="na">clear</span><span class="o">().</span><span class="na">append</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">store</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">},</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="n">CommitPolicy</span><span class="o">.</span><span class="na">GROUP</span><span class="o">);</span>
</pre></div>
</div>
<div class="section" id="mixing-transactional-and-non-transactional-operations">
<h3>Mixing Transactional and Non-Transactional Operations<a class="headerlink" href="#mixing-transactional-and-non-transactional-operations" title="Permalink to this headline">¶</a></h3>
<p>Database operations running outside the scope of an explicitly defined transaction are never subject to rollback and therefore do not require retry logic. However, such operations are also not guaranteed to be durable in the event of a system crash. Further, such operations are not isolated. Read operations performed outside of a transaction can read uncommitted updates, and updates performed outside of a transaction are visible within transactions. In other words, non-transactional reads and writes may break both the durability and isolation of concurrently executing transactions.  Therefore it is strongly recommended that in an application that relies on transactions, all interactions with the database should use transactions.</p>
</div>
</div>
<div class="section" id="optimistic-transaction-scheduling">
<h2>Optimistic Transaction Scheduling<a class="headerlink" href="#optimistic-transaction-scheduling" title="Permalink to this headline">¶</a></h2>
<p>To achieve high performance and scalability, Persistit supports an optimistic transaction scheduling protocol called MVCC with <a class="reference external" href="http://wikipedia.org/wiki/Snapshot_isolation">Snapshot Isolation</a>. Under this protocol multiple threads are permitted to execute transactions at full speed without blocking until a potentially inconsistent state is recognized. At that point a transaction suspected of causing the inconsistent state is automatically forced to roll back.</p>
<p>Optimistic scheduling works because transactions usually do not collide, especially when individual database operations are fast, and so in practice transactions are seldom rolled back. But because any transaction may be rolled back at any point, applications must be designed carefully to avoid unintended side-effects. For example, a transaction should never perform non-repeatable or externally visible operations such as file or network I/O within its scope.</p>
<div class="section" id="id3">
<h3>Snapshot Isolation<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>Persistit schedules concurrently executing transactions optimistically, without locking any database records. Instead, Persistit uses the well-known Snapshot Isolation protocol to achieve atomicity and isolation. While transactions are modifying data, Persistit maintains multiple versions of values being modified. Each version is labeled with the commit timestamp of the transaction that modified it. Whenever a transaction reads a value that has been modified by other transactions, it gets the latest version that was committed before its own start timestamp. In other words, all read operations are performed as if from a &#8220;snapshot&#8221; of the state of the database made at the transaction&#8217;s start timestamp - hence the name &#8220;Snapshot Isolation.&#8221;</p>
</div>
<div class="section" id="pruning">
<span id="id4"></span><h3>Pruning<a class="headerlink" href="#pruning" title="Permalink to this headline">¶</a></h3>
<p>Given that all updates written through transactions are created as versions within the MVCC scheme, a large number of versions can accumulate over time. Persistit reduces this proliferation through an activity called &#8220;pruning.&#8221; Pruning resolves the final state of each version by removing any versions created by aborted transactions and removing obsolete versions no longer needed by other transactions. If a value contains only one version and the commit timestamp of the transaction that created it is before the start of any currently running transaction, that value is called <em>primordial</em>. The goal of pruning is to reduce most or all values in the database to their primordial states because updating and reading primordial values is more efficient than than managing multiple version values. Pruning happens automatically and is generally not visible to the application.</p>
</div>
<div class="section" id="rollbacks">
<h3>Rollbacks<a class="headerlink" href="#rollbacks" title="Permalink to this headline">¶</a></h3>
<p>Usually Snapshot Isolation allows concurrent transactions to commit without interference but this is not always the case. Two concurrent transactions that attempt to modify the same Persistit key/value pair before they commit are said to have a &#8220;write-write dependency&#8221;. To avoid anomalous results one of them must abort, rolling back any other updates it may also have created, and retry. Persistit implements a &#8220;first updater wins&#8221; policy in which if two transactions attempt to update the same record, the first transaction &#8220;wins&#8221; by being allowed to continue, while the second transaction &#8220;loses&#8221; and is required to abort.</p>
<p>Once a transaction has aborted, any subsequent database operation it attempts throws a <tt class="docutils literal"><span class="pre">RollbackException</span></tt>. Application code should catch and handle this Exception. Usually the correct and desired behavior is simply to retry the transaction as shown in the code samples above.</p>
<p>A transaction can also voluntarily roll back. For example, transaction logic could detect an error condition that it chooses to handle by throwing an exception back to the application. In this case the transaction should invoke the <tt class="docutils literal"><span class="pre">rollback</span></tt> method to explicitly declare its intent to abort the transaction.</p>
</div>
<div class="section" id="read-only-transactions">
<h3>Read-Only Transactions<a class="headerlink" href="#read-only-transactions" title="Permalink to this headline">¶</a></h3>
<p>Under Snapshot Isolation, transactions that read but do not modify data cannot generate any write-write dependencies and are therefore not subject to  being rolled back because of the actions of other transactions. However, even though it modifies no data, a long-running read-only transaction can force Persistit to retain old value versions from other transactions for its duration in order to provide a snapshot view. This behavior can cause congestion and performance degradation by preventing very old values from being pruned. The degree to which this is a problem depends on the volume of update transactions being processed and the duration of long-running transactions.</p>
</div>
<div class="section" id="snapshot-isolation-is-not-serializable">
<h3>Snapshot Isolation is not Serializable<a class="headerlink" href="#snapshot-isolation-is-not-serializable" title="Permalink to this headline">¶</a></h3>
<p>It is well-known that transactions executing under SI are not necessarily serializable. Under SI, so-called <em>write-skew</em> anomalies can happen with transactions that have certain kinds of interactions.  Write-skew can be avoided by (a) explicit application-level locking or (b) structuring transactions to add write-write dependencies where write-skew otherwise could occur.</p>
<p>Note that many common transaction patterns, including those defined by the TPC-C benchmark, do not experience write-skew and therefore <em>are</em> serializable under SI.</p>
<p>In the unusual case where transactions are susceptible to write skew, the Exchange#lock method offers a way for applications to create a write-write dependency explicitly. This mechanism provides an efficient mechanism for ensuring serializable behavior.</p>
</div>
</div>
<div class="section" id="durability-options-commitpolicy">
<h2>Durability Options: <tt class="docutils literal"><span class="pre">CommitPolicy</span></tt><a class="headerlink" href="#durability-options-commitpolicy" title="Permalink to this headline">¶</a></h2>
<p>Persistit provides three policies that determine the durability of a transaction after it has executed the <a class="reference external" href="apidocs/com/persistit/Transaction.html#commit()">commit</a> method. These are:</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">HARD</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">commit</span></tt> method does not return until all updates created by the transaction have been written to non-volatile storage (e.g., disk storage).</dd>
<dt><tt class="docutils literal"><span class="pre">GROUP</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">commit</span></tt> method does not return until all updates created by the transaction have been written to non-volatile storage. In addition, the committing
transaction waits briefly in an attempt to recruit other transactions running in other threads to write their updates with the same physical I/O operation.</dd>
<dt><tt class="docutils literal"><span class="pre">SOFT</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">commit</span></tt> method returns <em>before</em> the updates have been recorded on non-volatile storage. Persistit attempts to write them within 100 milliseconds, but
this interval is not guaranteed.</dd>
</dl>
</div></blockquote>
<p>You can specify a default policy in the Persistit initialization properties using the <tt class="docutils literal"><span class="pre">txnpolicy</span></tt> property or under program control using <a class="reference external" href="apidocs/com/persistit/Persistit.html#setDefaultTransactionCommitPolicy(com.persistit.Transaction.CommitPolicy)">setDefaultTransactionCommitPolicy</a>. The default policy applies whenever the application calls the <tt class="docutils literal"><span class="pre">commit()</span></tt> method. You can override the default policy using <tt class="docutils literal"><span class="pre">commit(CommitPolicy)</span></tt>.</p>
<p>HARD and GROUP ensure each transaction is written durably to non-volatile storage before the <tt class="docutils literal"><span class="pre">commit</span></tt> method returns. The difference is that GROUP can improve throughput in multi-threaded applications because the average number of I/O operations needed to commit <em>N</em> transactions can be smaller than <em>N</em>. However, for one or a small number of concurrent threads, GROUP reduces throughput because it works by introducing a delay to allow other concurrent transactions to commit within a single I/O operation.</p>
<p>SOFT commits are generally much faster than HARD or GROUP commits, especially for single-threaded applications, because the results of numerous transactions committed from a single thread can be aggregated and written to disk in a single I/O operation. However, transactions written with the SOFT commit policy are not immediately durable and it is possible that the recovered state of a database will be missing transactions that reported they were committed shortly before a crash.</p>
<p>For SOFT commits, the state of the database after restart is such that for any committed transaction T, either all or none of its modifications will be present in the recovered database. Further, if a transaction T2 reads or updates data that was written by any other transaction T1, and if T2 is present in the recovered database, then so is T1. Any transaction that was in progress, but had not been committed at the time of the failure, is guaranteed not to be present in the recovered database. SOFT commits are designed to be durable within 100 milliseconds after <tt class="docutils literal"><span class="pre">commit</span></tt> returns. However, this interval is determined by computing the average duration of recent I/O operations to predict the completion time of the I/O that will write the transaction to disk, and therefore the interval cannot be guaranteed.</p>
</div>
<div class="section" id="nested-transactions">
<h2>Nested Transactions<a class="headerlink" href="#nested-transactions" title="Permalink to this headline">¶</a></h2>
<p>A nested transaction occurs when code that is already executing within the scope of a transaction executes the <tt class="docutils literal"><span class="pre">begin</span></tt> method to start a new transaction. This might happen, for example, if an application’s transaction logic calls a method that also uses transactions. In this case, the commit processing of the inner transaction scope is deferred until the outermost transaction commits. At that point, all the updates performed within the inner and outer transaction scopes are committed to the database. Similarly, a rollback initiated by the inner transaction causes both it and the outermost transaction to roll back.</p>
</div>
<div class="section" id="accumulators">
<h2>Accumulators<a class="headerlink" href="#accumulators" title="Permalink to this headline">¶</a></h2>
<p>Consider an application in which concurrently running transactions share a counter. For example, suppose each transaction is responsible for allocating a unique integer as a primary key for a database record. One way to do this would be to store the counter in a Persistit key/value pair, reading the value at the start of each transaction and committing an update at the end.</p>
<p>The problem with this approach is that under SI, concurrent transactions running in a multi-threaded application would experience very frequent write-write dependencies on the counter value; in fact, the only way to complete any transactions would be serially, one at a time.</p>
<p>Persistit provides the <a class="reference external" href="apidocs/com/persistit/Accumulator.html">com.persistit.Accumulator</a> class to avoid this problem.  An accumulator is designed to manage contributions from multiple concurrent transactions without causing write-write dependencies. Accumulators are durable in the sense that each transaction’s contribution is made durable with the transaction itself, and Persistit automatically recovers a correct state for each Accumulator in the event of a system crash.</p>
<p>There are four types of accumulator in Persistit. Each is a concrete subclass of the abstract <a class="reference external" href="apidocs/com/persistit/Accumulator.html">com.persistit.Accumulator</a> class:</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">SUM</span></tt></dt>
<dd>Tallies a count or sum of contributions by each transaction</dd>
<dt><tt class="docutils literal"><span class="pre">MIN</span></tt></dt>
<dd>Finds the minimum value contributed by all transactions</dd>
<dt><tt class="docutils literal"><span class="pre">MAX</span></tt></dt>
<dd>Finds the maximum value contributed by all transactions</dd>
<dt><tt class="docutils literal"><span class="pre">SEQ</span></tt></dt>
<dd>Special case of the SUM accumulator used to generate sequence numbers</dd>
</dl>
</div></blockquote>
<p>Accumulator instances are associated with a <a class="reference external" href="apidocs/com/persistit/Tree.html">com.persistit.Tree</a>.  Each <tt class="docutils literal"><span class="pre">Tree</span></tt> may have up to 64 accumulators. The following code fragment creates and/or acquires a <tt class="docutils literal"><span class="pre">SumAccumulator</span></tt>, reads its snapshot value and then adds one to it:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kd">final</span> <span class="n">Exchange</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">_persistit</span><span class="o">.</span><span class="na">getExchange</span><span class="o">(</span><span class="n">volume</span><span class="o">,</span> <span class="n">treeName</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">Transaction</span> <span class="n">txn</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
<span class="n">txn</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Accumulator</span> <span class="n">acc</span> <span class="o">=</span>
        <span class="n">ex</span><span class="o">.</span><span class="na">getTree</span><span class="o">().</span><span class="na">getAccumulator</span><span class="o">(</span><span class="n">Accumulator</span><span class="o">.</span><span class="na">Type</span><span class="o">.</span><span class="na">SUM</span><span class="o">,</span> <span class="mi">17</span><span class="o">);</span>
    <span class="kt">long</span> <span class="n">snap</span> <span class="o">=</span> <span class="n">acc</span><span class="o">.</span><span class="na">getSnapshotValue</span><span class="o">(</span><span class="n">txn</span><span class="o">);</span>
    <span class="n">acc</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">txn</span><span class="o">);</span>
    <span class="n">txn</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">txn</span><span class="o">.</span><span class="na">end</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The value 17 is simply an arbitrary index number between 0 and 63, inclusive. The application is responsible for allocating and managing accumulator indexes.</p>
<p>The snapshot value of an accumulator obtained through <a class="reference external" href="apidocs/com/persistit/Accumulator.html#getSnapshotValue()">getSnapshotValue</a> is the value computed from all updates contributed by transactions that had committed at the time the current transaction started, plus the transaction’s own as-yet uncommitted updates. In other words, the snapshot value of the accumulator is consistent with the snapshot view of all other data visible within the transaction.</p>
<p>An accumulator has two ways of accessing its accumulated value:</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">getSnapshotValue()</span></tt></dt>
<dd>Is a value computed from updates that were committed at the start of the current transaction. This method may be called only within the scope of a
Transaction.</dd>
<dt><tt class="docutils literal"><span class="pre">getLiveValue()</span></tt></dt>
<dd>Is an ephemeral value reflecting all updates performed by all transactions, including concurrent and aborted transactions.</dd>
</dl>
</div></blockquote>
<p>The snapshot value is a precise, consistent tally, while the live value is approximate. For a <tt class="docutils literal"><span class="pre">SumAccumulator</span></tt>, <tt class="docutils literal"><span class="pre">MaxAccumulator</span></tt> or <tt class="docutils literal"><span class="pre">SeqAccumulator</span></tt>, if all updates are have non-negative arguments, then the live value is always greater than or equal to the snapshot value.</p>
<div class="section" id="seqaccumulator">
<h3>SeqAccumulator<a class="headerlink" href="#seqaccumulator" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">SeqAccumulator</span></tt> class has a special role in allocating unique identifier numbers, e.g., synthetic primary keys.  The goal of the <tt class="docutils literal"><span class="pre">SeqAccumulator</span></tt> is to ensure that every committed transaction has received a unique value integer in all circumstances, including after recovery from a crash. See <a class="reference external" href="apidocs/com/persistit/Accumulator.html">com.persistit.Accumulator</a> for details.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Transactions</a><ul>
<li><a class="reference internal" href="#using-transactions">Using Transactions</a><ul>
<li><a class="reference internal" href="#mixing-transactional-and-non-transactional-operations">Mixing Transactional and Non-Transactional Operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optimistic-transaction-scheduling">Optimistic Transaction Scheduling</a><ul>
<li><a class="reference internal" href="#id3">Snapshot Isolation</a></li>
<li><a class="reference internal" href="#pruning">Pruning</a></li>
<li><a class="reference internal" href="#rollbacks">Rollbacks</a></li>
<li><a class="reference internal" href="#read-only-transactions">Read-Only Transactions</a></li>
<li><a class="reference internal" href="#snapshot-isolation-is-not-serializable">Snapshot Isolation is not Serializable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#durability-options-commitpolicy">Durability Options: <tt class="docutils literal"><span class="pre">CommitPolicy</span></tt></a></li>
<li><a class="reference internal" href="#nested-transactions">Nested Transactions</a></li>
<li><a class="reference internal" href="#accumulators">Accumulators</a><ul>
<li><a class="reference internal" href="#seqaccumulator">SeqAccumulator</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="BasicAPI.html"
                        title="previous chapter">Basic API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="PhysicalStorage.html"
                        title="next chapter">Physical B+Tree Representation</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="PhysicalStorage.html" title="Physical B+Tree Representation"
             >next</a></li>
        <li class="right" >
          <a href="BasicAPI.html" title="Basic API"
             >previous</a> |</li>
        <li><a href="index.html">Persistit 3.3.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Akiban Technologies.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b3.
    </div>
  </body>
</html>